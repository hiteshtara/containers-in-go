Basics
A slice doesn’t store any data, it just describes a section of an underlying array.

When you change an element of a slice, you modify the corresponding element of its underlying array, and other slices that share the same underlying array will see the change.
A slice can grow and shrink within the bounds of the underlying array.
Slices are indexed in the usual way: s[i] accesses the ith element, starting from zero. 
var s []int                   // a nil slice
s1 := []string{"foo", "bar"}
s2 := make([]int, 2)          // same as []int{0, 0}
s3 := make([]int, 2, 4)       // same as new([4]int)[:2]
fmt.Println(len(s3), cap(s3)) // 2 4

a := [...]int{0, 1, 2, 3} // an array
s := a[1:3]               // s == []int{1, 2}        cap(s) == 3
s = a[:2]                 // s == []int{0, 1}        cap(s) == 4
s = a[2:]                 // s == []int{2, 3}        cap(s) == 2
s = a[:]                  // s == []int{0, 1, 2, 3}  cap(s) == 4

s := []int{0, 1, 2, 3, 4} // a slice
s = s[1:4]                // s == []int{1, 2, 3}
s = s[1:2]                // s == []int{2} (index relative to slice)
s = s[:3]                 // s == []int{2, 3, 4} (extend length)

s := []string{"Foo", "Bar"}
for i, v := range s {
    fmt.Println(i, v)
}
The built-in copy function copies elements into a destination slice dst from a source slice src.
func copy(dst, src []Type) int
It returns the number of elements copied, which will be the minimum of len(dst) and len(src). The result does not depend on whether the arguments overlap.

It is legal to copy bytes from a string to a slice of bytes.
copy(dst []byte, src string) int
var s = make([]int, 3)
n := copy(s, []int{0, 1, 2, 3}) // n == 3, s == []int{0, 1, 2}
s := []int{0, 1, 2}
n := copy(s, s[1:]) // n == 2, s == []int{1, 2, 2}
var b = make([]byte, 5)
copy(b, "Hello, world!") // b == []byte("Hello")
The idiomatic way to implement a stack in Go is to use a slice:

to push you use the built-in append function, and
to pop you slice off the top element.
var stack []string

stack = append(stack, "world!") // Push
stack = append(stack, "Hello ")

for len(stack) > 0 {
    n := len(stack) - 1 // Top element
    fmt.Print(stack[n])

    stack = stack[:n] // Pop
}
Watch out for memory leaks
If the stack is permanent and the elements temporary, you may want to remove the top element before popping the stack.

// Pop
stack[n] = "" // Erase element (write zero value)
stack = stack[:n]

3 ways to compare slices

/ Equal tells whether a and b contain the same elements.
// A nil argument is equivalent to an empty slice.
func Equal(a, b []int) bool {
    if len(a) != len(b) {
        return false
    }
    for i, v := range a {
        if v != b[i] {
            return false
        }
    }
    return true
}

var a []int = nil
var b []int = make([]int, 0)
fmt.Println(reflect.DeepEqual(a, b)) // false

The performance of this function is much worse than for the code above, but it’s useful in test cases where simplicity and correctness are crucial. The semantics, however, are quite complicated.
To remove all elements, set the slice to nil.
a := []string{"A", "B", "C", "D", "E"}
a = nil
fmt.Println(a, len(a), cap(a)) // [] 0 0
This will release the underlying array to the garbage collector (assuming there are no other references).

Note that nil slices and empty slices are very similar:

they look the same when printed,
they have zero length and capacity,
they can be used with the same effect in for loops and append functions.
Keep allocated memory
To keep the underlying array, slice the slice to zero length.
a := []string{"A", "B", "C", "D", "E"}
a = a[:0]
fmt.Println(a, len(a), cap(a)) // [] 0 5
If the slice is extended again, the original data reappears.
fmt.Println(a[:2]) // [A B]
Concatenate slices

a := []int{1, 2}
b := []int{11, 22}
a = append(a, b...) // a == [1 2 11 22]
The ... unpacks b. Without the dots, the code would attempt to append the slice as a whole, which is invalid.

Delete an element from a slice
Fast version (changes order)
a := []string{"A", "B", "C", "D", "E"}
i := 2

// Remove the element at index i from a.
a[i] = a[len(a)-1] // Copy last element to index i.
a[len(a)-1] = ""   // Erase last element (write zero value).
a = a[:len(a)-1]   // Truncate slice.

fmt.Println(a) // [A B E D]

Slow version (maintains order)
a := []string{"A", "B", "C", "D", "E"}
i := 2

// Remove the element at index i from a.
copy(a[i:], a[i+1:]) // Shift a[i+1:] left one index.
a[len(a)-1] = ""     // Erase last element (write zero value).
a = a[:len(a)-1]     // Truncate slice.

fmt.Println(a) // [A B D E]

Find an element in a slice
/ Contains tells whether a contains x.
func Contains(a []string, x string) bool {
    for _, n := range a {
        if x == n {
            return true
        }
    }
    return false
}
/ Find returns the smallest index i at which x == a[i],
// or len(a) if there is no such index.
func Find(a []string, x string) int {
    for i, n := range a {
        if x == n {
            return i
        }
    }
    return len(a)
}

Last item in a slice
a := []string{"A", "B", "C"}
s := a[len(a)-1] // C
To remove it:
a = a[:len(a)-1] // [A B]
Watch out for memory leaks
If the slice is permanent and the element temporary, you may want to remove the reference before removing the element from the slice.

a[len(a)-1] = "" // Erase element (write zero value)
a = a[:len(a)-1] // [A B]
Empty slice vs. nil slice
In practice, nil slices and empty slices can often be treated in the same way:

they have zero length and capacity,
they can be used with the same effect in for loops and append functions,
and they even look the same when printed.
var a []int = nil
fmt.Println(len(a)) // 0
fmt.Println(cap(a)) // 0
fmt.Println(a)      // []
However, if needed, you can tell the difference.
var a []int = nil
var a0 []int = make([]int, 0)

fmt.Println(a == nil)  // true
fmt.Println(a0 == nil) // false

fmt.Printf("%#v\n", a)  // []int(nil)
fmt.Printf("%#v\n", a0) // []int{}
The official Go wiki recommends using nil slices over empty slices.

[…] the nil slice is the preferred style.

Note that there are limited circumstances where a non-nil but zero-length slice is preferred, such as when encoding JSON objects (a nil slice encodes to null, while []string{} encodes to the JSON array []).

When designing interfaces, avoid making a distinction between a nil slice and a non-nil, zero-length slice, as this can lead to subtle programming errors.
Pass a slice to a variadic function
ou can pass a slice s directly to a variadic funtion using the s... notation
func main() {
    primes := []int{2, 3, 5, 7}
    fmt.Println(Sum(primes...)) // 17
}   

func Sum(nums ...int) int {
    res := 0
    for _, n := range nums {
        res += n
    }
    return res
}

+++++++++++++++++++++++++++++++
var m map[string]int                // m == nil, len(m) == 0
m1 := make(map[string]float64)      // empty map of string-float64 pairs
m2 := make(map[string]float64, 100) // preallocate room for 100 entries
m3 := map[string]float64{
    "e":  2.71828,
    "pi": 3.1416,
}
fmt.Println(len(m1), len(m2), len(m3)) // 0 0 2
The default zero value of a map is nil. A nil map is equivalent to an empty map except that no elements can be added.
You create a map either by a map literal or a call to the make function, which takes an optional capacity as argument.
The built-in len function retrieves the number of key-value pairs.

Add, find and delete

m := make(map[string]float64)

m["pi"] = 3.1416 // Add a new key-value pair.
fmt.Println(m)   // map[pi:3.1416]

v1 := m["pi"]  // v1 == 3.1416
v2 := m["foo"] // v2 == 0 (zero value)

_, exists := m["pi"] // exists == true
_, exists = m["foo"] // exists == false

if x, ok := m["pi"]; ok { // Prints 3.1416.
    fmt.Println(x)
}

delete(m, "pi") // Delete a key-value pair.
fmt.Println(m)  // map[]
Iteration
m := map[string]float64{
    "e":  2.71828,
    "pi": 3.1416,
}
for key, value := range m { // order not specified 
    fmt.Println(key, value)
}
Check if a map contains a key
m := map[string]float64{"pi": 3.1416}

v1 := m["pi"]  // v1 == 3.1416
v2 := m["foo"] // v2 == 0.0 (zero value)

_, exists := m["pi"] // exists == true

if x, ok := m["pi"]; ok {
    fmt.Println(x) // 3.1416
}
Check if a map is empty
if len(m) == 0 {
    // m is empty
}
Count elements in a map
m := map[string]int{
    "key1": 1,
    "key2": 10,
    "key3": 100,
}
fmt.Println(len(m))  // 3
Get slices of keys and values from a map
keys := make([]keyType, 0, len(myMap))
values := make([]valueType, 0, len(myMap))

for k, v := range myMap {
	keys = append(keys, k)
	values = append(values, v)
}

Sort a map by key or value
 map is an unordered collection of key-value pairs.
If you need a stable iteration order, you must maintain a separate data structure.
This example uses a sorted slice of keys to print a map[string]int in key order.
m := map[string]int{"Alice": 23, "Eve": 2, "Bob": 25}

keys := make([]string, 0, len(m))
for k := range m {
	keys = append(keys, k)
}
sort.Strings(keys)

for _, k := range keys {
	fmt.Println(k, m[k])
}

Format a string without printing it

s := fmt.Sprintf("Size: %d MB.", 85) // s == "Size: 85 MB."

Type rune: a Unicode code point
The rune type is an alias for int32, and is used to emphasize than an integer represents a code point.
CII defines 128 characters, identified by the code points 0–127. It covers English letters, Latin numbers, and a few other characters.
Unicode, which is a superset of ASCII, defines a codespace of 1,114,112 code points. Unicode version 10.0 covers 139 modern and historic scripts (including runes, but not Klingon) as well as multiple symbol sets.
Strings and UTF-8
Note that a string is a sequence of bytes, not runes.
However, strings often contain Unicode text encoded in UTF-8, which encodes all Unicode code points using one to four bytes. Since Go source code itself is encoded as UTF-8, string literals will automatically get this encoding.
For simple cases where performance is a non-issue, fmt.Sprintf is your friend.
s := fmt.Sprintf("Size: %d MB.", 85) // s == "Size: 85 MB."
Fast concatenation with a string builder
The strings.Builder type is used to efficiently concatenate strings using write methods.

It offers a subset of the bytes.Buffer methods that allows it to safely avoid redundant copying.
The Grow method can be used to preallocate memory when the maximum size of the string is known.
var b strings.Builder
b.Grow(32)
for i, p := range []int{2, 3, 5, 7, 11, 13} {
    fmt.Fprintf(&b, "%d:%d, ", i+1, p)
}
s := b.String()   // no copying
s = s[:b.Len()-2] // no copying (removes trailing ", ")
fmt.Println(s)
1:2, 2:3, 3:5, 4:7, 5:11, 6:13
var buf bytes.Buffer
for i, p := range []int{2, 3, 5, 7, 11, 13} {
    fmt.Fprintf(&buf, "%d:%d, ", i+1, p)
}
buf.Truncate(buf.Len() - 2) // Remove trailing ", "
s := buf.String()           // Copy into a new string
fmt.Println(s)
buf := []byte("Size: ")
buf = strconv.AppendInt(buf, 85, 10)
buf = append(buf, " MB."...)
s := string(buf)
buf := make([]byte, 0, 16)
buf = append(buf, "Size: "...)
buf = strconv.AppendInt(buf, 85, 10)
buf = append(buf, " MB."...)
s := string(buf)
How to split a string into a slice
s := strings.Split("a,b,c", ",")
fmt.Println(s)
// Output: [a b c]
Use the strings.Fields function to split a string into substrings removing white space.
s := strings.Fields(" a \t b \n")
fmt.Println(s)
// Output: [a b]
if "Foo" == "Bar" {
    fmt.Println("Foo and Bar are equal.")
} else {
    fmt.Println("Foo and Bar are not equal.")
}
// Output: Foo and Bar are not equal.
Use <, >, <= or >= to determine lexical order.

f "Foo" < "Bar" {
    fmt.Println("Foo comes before Bar.")
} else {
    fmt.Println("Foo does not come before Bar.")
}
// Output: Foo does not come before Bar.
Convert string to/from byte slice
When you convert a string to a byte slice, you get a slice that contains the bytes of the string.
fmt.Println([]byte("abc日")
// [97 98 99 230 151 165]
Converting a slice of bytes to a string yields a string whose bytes are the elements of the slice.
b := []byte{'a', 'b', 'c', '\xe6', '\x97', '\xa5'}
s := string(b)
fmt.Println(s)
// Output: abc日
Convert string to/from rune slice
Converting a string to a slice of runes yields a slice whose elements are the Unicode code points of the string.
s := "abc日"
r := []rune(s)
fmt.Printf("%v\n", r) // [97 98 99 26085]
fmt.Printf("%U\n", r) // [U+0061 U+0062 U+0063 U+65E5]
Rune slice to string
Converting a slice of runes to a string yields a string that is the concatenation of the runes converted to UTF-8 encoded strings.

Values outside the range of valid Unicode code points are converted to \uFFFD, the Unicode replacement character �.
r := []rune{'\u0061', '\u0062', '\u0063', '\u65E5', -1}
s := string(r)
fmt.Println(s) // abc日�
Convert int/int64 to string
int to string
Use the strconv.Itoa function to convert an int to a decimal string.
str := strconv.Itoa(123) // str == "123"
nt64 to string
Use strconv.FormatInt to format an integer in a given base.
var n int64 = 32
str := strconv.FormatInt(n, 10) // decimal
fmt.Println(str)                // 32
var n int64 = 32
str := strconv.FormatInt(n, 16) // hexadecimal
fmt.Println(str)                // 20
Use strconv.Atoi to convert/parse a string to an int.
str := "123"
if n, err := strconv.Atoi(str); err == nil {
    fmt.Println(n+1)
} else {
    fmt.Println(str, "is not an integer.")
}
// Output: 124
String to int64
Use strconv.ParseInt to parse a decimal string (base 10) and check if it fits into a 64-bit signed integer.
str := "123"
n, err := strconv.ParseInt(str, 10, 64)
if err == nil {
    fmt.Printf("%d of type %T", n, n)
}
// Output: 123 of type int64
he two numeric arguments represent a base (0, 2 to 36) and a bit size (0 to 64).

If the first argument is 0, the base is implied by the string’s prefix: base 16 for "0x", base 8 for "0", and base 10 otherwise.

The second argument specifies the integer type that the result must fit into. Bit sizes 0, 8, 16, 32, and 64 correspond to int, int8, int16, int32, and int64.
Use the fmt.Sprintf method to convert a floating-point number to a string.
s := fmt.Sprintf("%f", 123.456) // s == "123.456000"
Use the strconv.ParseFloat function to convert a string to a floating-point number with the precision specified by bitSize: 32 for float32, or 64 for float64.

func ParseFloat(s string, bitSize int) (float64, error)
When bitSize is 32, the result still has type float64, but it will be convertible to float32 without changing its value.

f := "3.14159265"
if s, err := strconv.ParseFloat(f, 32); err == nil {
    fmt.Println(s) // 3.1415927410125732
}
if s, err := strconv.ParseFloat(f, 64); err == nil {
    fmt.Println(s) // 3.14159265
}
Raw string literals
Raw string literals, delimited by back quotes, can contain line breaks.
str := `First line
Second line`
fmt.Println(str)
Raw strings literals are interpreted literally and backslashes have no special meaning.

Interpreted string literals
To insert escape characters, use interpreted string literals delimited by double quotes.
str := "\tFirst line\n" +
"Second line"
fmt.Println(str)
Remove duplicate whitespace
space := regexp.MustCompile(`\s+`)
s := space.ReplaceAllString("Hello  \t \n world!", " ")
fmt.Printf("%q", s) // "Hello world!"
\s+ is a regular expression:

the character class \s matches a space, tab, new line, carriage return or form feed,
and + says “one or more of those”.
In other words, the code will replace each whitespace substring with a single space character.
Use the strings.TrimSpace function to remove leading and trailing whitespace as defined by Unicode.
s := strings.TrimSpace("\t Goodbye hair!\n ")
fmt.Printf("%q", s) // "Goodbye hair!"
s := strings.Repeat("da", 2) // "dada"
Reverse a UTF-8 encoded string
This function returns a string with the UTF-8 encoded characters of s in reverse order. Invalid UTF-8 sequences, if any, will be reversed byte by byte.
func ReverseUTF8(s string) string {
    res := make([]byte, len(s))
    prevPos, resPos := 0, len(s)
    for pos := range s {
        resPos -= pos - prevPos
        copy(res[resPos:], s[prevPos:pos])
        prevPos = pos
    }
    copy(res[0:], s[prevPos:])
    return string(res)
}
for _, s := range []string{
	"Ångström",
	"Hello, 世界",
	"\xff\xfe\xfd", // invalid UTF-8
} {
	fmt.Printf("%q\n", ReverseUTF8(s))
}
"mörtsgnÅ"
"界世 ,olleH"
"\xfd\xfe\xff"
