Basics
A slice doesn’t store any data, it just describes a section of an underlying array.

When you change an element of a slice, you modify the corresponding element of its underlying array, and other slices that share the same underlying array will see the change.
A slice can grow and shrink within the bounds of the underlying array.
Slices are indexed in the usual way: s[i] accesses the ith element, starting from zero. 
var s []int                   // a nil slice
s1 := []string{"foo", "bar"}
s2 := make([]int, 2)          // same as []int{0, 0}
s3 := make([]int, 2, 4)       // same as new([4]int)[:2]
fmt.Println(len(s3), cap(s3)) // 2 4

a := [...]int{0, 1, 2, 3} // an array
s := a[1:3]               // s == []int{1, 2}        cap(s) == 3
s = a[:2]                 // s == []int{0, 1}        cap(s) == 4
s = a[2:]                 // s == []int{2, 3}        cap(s) == 2
s = a[:]                  // s == []int{0, 1, 2, 3}  cap(s) == 4

s := []int{0, 1, 2, 3, 4} // a slice
s = s[1:4]                // s == []int{1, 2, 3}
s = s[1:2]                // s == []int{2} (index relative to slice)
s = s[:3]                 // s == []int{2, 3, 4} (extend length)

s := []string{"Foo", "Bar"}
for i, v := range s {
    fmt.Println(i, v)
}
The built-in copy function copies elements into a destination slice dst from a source slice src.
func copy(dst, src []Type) int
It returns the number of elements copied, which will be the minimum of len(dst) and len(src). The result does not depend on whether the arguments overlap.

It is legal to copy bytes from a string to a slice of bytes.
copy(dst []byte, src string) int
var s = make([]int, 3)
n := copy(s, []int{0, 1, 2, 3}) // n == 3, s == []int{0, 1, 2}
s := []int{0, 1, 2}
n := copy(s, s[1:]) // n == 2, s == []int{1, 2, 2}
var b = make([]byte, 5)
copy(b, "Hello, world!") // b == []byte("Hello")
The idiomatic way to implement a stack in Go is to use a slice:

to push you use the built-in append function, and
to pop you slice off the top element.
var stack []string

stack = append(stack, "world!") // Push
stack = append(stack, "Hello ")

for len(stack) > 0 {
    n := len(stack) - 1 // Top element
    fmt.Print(stack[n])

    stack = stack[:n] // Pop
}
Watch out for memory leaks
If the stack is permanent and the elements temporary, you may want to remove the top element before popping the stack.

// Pop
stack[n] = "" // Erase element (write zero value)
stack = stack[:n]

3 ways to compare slices

/ Equal tells whether a and b contain the same elements.
// A nil argument is equivalent to an empty slice.
func Equal(a, b []int) bool {
    if len(a) != len(b) {
        return false
    }
    for i, v := range a {
        if v != b[i] {
            return false
        }
    }
    return true
}

var a []int = nil
var b []int = make([]int, 0)
fmt.Println(reflect.DeepEqual(a, b)) // false

The performance of this function is much worse than for the code above, but it’s useful in test cases where simplicity and correctness are crucial. The semantics, however, are quite complicated.
To remove all elements, set the slice to nil.
a := []string{"A", "B", "C", "D", "E"}
a = nil
fmt.Println(a, len(a), cap(a)) // [] 0 0
This will release the underlying array to the garbage collector (assuming there are no other references).

Note that nil slices and empty slices are very similar:

they look the same when printed,
they have zero length and capacity,
they can be used with the same effect in for loops and append functions.
Keep allocated memory
To keep the underlying array, slice the slice to zero length.
a := []string{"A", "B", "C", "D", "E"}
a = a[:0]
fmt.Println(a, len(a), cap(a)) // [] 0 5
If the slice is extended again, the original data reappears.
fmt.Println(a[:2]) // [A B]
Concatenate slices

a := []int{1, 2}
b := []int{11, 22}
a = append(a, b...) // a == [1 2 11 22]
The ... unpacks b. Without the dots, the code would attempt to append the slice as a whole, which is invalid.

Delete an element from a slice
Fast version (changes order)
a := []string{"A", "B", "C", "D", "E"}
i := 2

// Remove the element at index i from a.
a[i] = a[len(a)-1] // Copy last element to index i.
a[len(a)-1] = ""   // Erase last element (write zero value).
a = a[:len(a)-1]   // Truncate slice.

fmt.Println(a) // [A B E D]

Slow version (maintains order)
a := []string{"A", "B", "C", "D", "E"}
i := 2

// Remove the element at index i from a.
copy(a[i:], a[i+1:]) // Shift a[i+1:] left one index.
a[len(a)-1] = ""     // Erase last element (write zero value).
a = a[:len(a)-1]     // Truncate slice.

fmt.Println(a) // [A B D E]

Find an element in a slice
/ Contains tells whether a contains x.
func Contains(a []string, x string) bool {
    for _, n := range a {
        if x == n {
            return true
        }
    }
    return false
}
/ Find returns the smallest index i at which x == a[i],
// or len(a) if there is no such index.
func Find(a []string, x string) int {
    for i, n := range a {
        if x == n {
            return i
        }
    }
    return len(a)
}

Last item in a slice
a := []string{"A", "B", "C"}
s := a[len(a)-1] // C
To remove it:
a = a[:len(a)-1] // [A B]
Watch out for memory leaks
If the slice is permanent and the element temporary, you may want to remove the reference before removing the element from the slice.

a[len(a)-1] = "" // Erase element (write zero value)
a = a[:len(a)-1] // [A B]
Empty slice vs. nil slice
In practice, nil slices and empty slices can often be treated in the same way:

they have zero length and capacity,
they can be used with the same effect in for loops and append functions,
and they even look the same when printed.
var a []int = nil
fmt.Println(len(a)) // 0
fmt.Println(cap(a)) // 0
fmt.Println(a)      // []
However, if needed, you can tell the difference.
var a []int = nil
var a0 []int = make([]int, 0)

fmt.Println(a == nil)  // true
fmt.Println(a0 == nil) // false

fmt.Printf("%#v\n", a)  // []int(nil)
fmt.Printf("%#v\n", a0) // []int{}
The official Go wiki recommends using nil slices over empty slices.

[…] the nil slice is the preferred style.

Note that there are limited circumstances where a non-nil but zero-length slice is preferred, such as when encoding JSON objects (a nil slice encodes to null, while []string{} encodes to the JSON array []).

When designing interfaces, avoid making a distinction between a nil slice and a non-nil, zero-length slice, as this can lead to subtle programming errors.
Pass a slice to a variadic function
ou can pass a slice s directly to a variadic funtion using the s... notation
func main() {
    primes := []int{2, 3, 5, 7}
    fmt.Println(Sum(primes...)) // 17
}   

func Sum(nums ...int) int {
    res := 0
    for _, n := range nums {
        res += n
    }
    return res
}