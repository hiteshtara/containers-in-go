Basics 
credit goes https://yourbasic.org/golang/measure-execution-time/
A slice doesn’t store any data, it just describes a section of an underlying array.

When you change an element of a slice, you modify the corresponding element of its underlying array, and other slices that share the same underlying array will see the change.
A slice can grow and shrink within the bounds of the underlying array.
Slices are indexed in the usual way: s[i] accesses the ith element, starting from zero. 
var s []int                   // a nil slice
s1 := []string{"foo", "bar"}
s2 := make([]int, 2)          // same as []int{0, 0}
s3 := make([]int, 2, 4)       // same as new([4]int)[:2]
fmt.Println(len(s3), cap(s3)) // 2 4

a := [...]int{0, 1, 2, 3} // an array
s := a[1:3]               // s == []int{1, 2}        cap(s) == 3
s = a[:2]                 // s == []int{0, 1}        cap(s) == 4
s = a[2:]                 // s == []int{2, 3}        cap(s) == 2
s = a[:]                  // s == []int{0, 1, 2, 3}  cap(s) == 4

s := []int{0, 1, 2, 3, 4} // a slice
s = s[1:4]                // s == []int{1, 2, 3}
s = s[1:2]                // s == []int{2} (index relative to slice)
s = s[:3]                 // s == []int{2, 3, 4} (extend length)

s := []string{"Foo", "Bar"}
for i, v := range s {
    fmt.Println(i, v)
}
The built-in copy function copies elements into a destination slice dst from a source slice src.
func copy(dst, src []Type) int
It returns the number of elements copied, which will be the minimum of len(dst) and len(src). The result does not depend on whether the arguments overlap.

It is legal to copy bytes from a string to a slice of bytes.
copy(dst []byte, src string) int
var s = make([]int, 3)
n := copy(s, []int{0, 1, 2, 3}) // n == 3, s == []int{0, 1, 2}
s := []int{0, 1, 2}
n := copy(s, s[1:]) // n == 2, s == []int{1, 2, 2}
var b = make([]byte, 5)
copy(b, "Hello, world!") // b == []byte("Hello")
The idiomatic way to implement a stack in Go is to use a slice:

to push you use the built-in append function, and
to pop you slice off the top element.
var stack []string

stack = append(stack, "world!") // Push
stack = append(stack, "Hello ")

for len(stack) > 0 {
    n := len(stack) - 1 // Top element
    fmt.Print(stack[n])

    stack = stack[:n] // Pop
}
Watch out for memory leaks
If the stack is permanent and the elements temporary, you may want to remove the top element before popping the stack.

// Pop
stack[n] = "" // Erase element (write zero value)
stack = stack[:n]

3 ways to compare slices

/ Equal tells whether a and b contain the same elements.
// A nil argument is equivalent to an empty slice.
func Equal(a, b []int) bool {
    if len(a) != len(b) {
        return false
    }
    for i, v := range a {
        if v != b[i] {
            return false
        }
    }
    return true
}

var a []int = nil
var b []int = make([]int, 0)
fmt.Println(reflect.DeepEqual(a, b)) // false

The performance of this function is much worse than for the code above, but it’s useful in test cases where simplicity and correctness are crucial. The semantics, however, are quite complicated.
To remove all elements, set the slice to nil.
a := []string{"A", "B", "C", "D", "E"}
a = nil
fmt.Println(a, len(a), cap(a)) // [] 0 0
This will release the underlying array to the garbage collector (assuming there are no other references).

Note that nil slices and empty slices are very similar:

they look the same when printed,
they have zero length and capacity,
they can be used with the same effect in for loops and append functions.
Keep allocated memory
To keep the underlying array, slice the slice to zero length.
a := []string{"A", "B", "C", "D", "E"}
a = a[:0]
fmt.Println(a, len(a), cap(a)) // [] 0 5
If the slice is extended again, the original data reappears.
fmt.Println(a[:2]) // [A B]
Concatenate slices

a := []int{1, 2}
b := []int{11, 22}
a = append(a, b...) // a == [1 2 11 22]
The ... unpacks b. Without the dots, the code would attempt to append the slice as a whole, which is invalid.

Delete an element from a slice
Fast version (changes order)
a := []string{"A", "B", "C", "D", "E"}
i := 2

// Remove the element at index i from a.
a[i] = a[len(a)-1] // Copy last element to index i.
a[len(a)-1] = ""   // Erase last element (write zero value).
a = a[:len(a)-1]   // Truncate slice.

fmt.Println(a) // [A B E D]

Slow version (maintains order)
a := []string{"A", "B", "C", "D", "E"}
i := 2

// Remove the element at index i from a.
copy(a[i:], a[i+1:]) // Shift a[i+1:] left one index.
a[len(a)-1] = ""     // Erase last element (write zero value).
a = a[:len(a)-1]     // Truncate slice.

fmt.Println(a) // [A B D E]

Find an element in a slice
/ Contains tells whether a contains x.
func Contains(a []string, x string) bool {
    for _, n := range a {
        if x == n {
            return true
        }
    }
    return false
}
/ Find returns the smallest index i at which x == a[i],
// or len(a) if there is no such index.
func Find(a []string, x string) int {
    for i, n := range a {
        if x == n {
            return i
        }
    }
    return len(a)
}

Last item in a slice
a := []string{"A", "B", "C"}
s := a[len(a)-1] // C
To remove it:
a = a[:len(a)-1] // [A B]
Watch out for memory leaks
If the slice is permanent and the element temporary, you may want to remove the reference before removing the element from the slice.

a[len(a)-1] = "" // Erase element (write zero value)
a = a[:len(a)-1] // [A B]
Empty slice vs. nil slice
In practice, nil slices and empty slices can often be treated in the same way:

they have zero length and capacity,
they can be used with the same effect in for loops and append functions,
and they even look the same when printed.
var a []int = nil
fmt.Println(len(a)) // 0
fmt.Println(cap(a)) // 0
fmt.Println(a)      // []
However, if needed, you can tell the difference.
var a []int = nil
var a0 []int = make([]int, 0)

fmt.Println(a == nil)  // true
fmt.Println(a0 == nil) // false

fmt.Printf("%#v\n", a)  // []int(nil)
fmt.Printf("%#v\n", a0) // []int{}
The official Go wiki recommends using nil slices over empty slices.

[…] the nil slice is the preferred style.

Note that there are limited circumstances where a non-nil but zero-length slice is preferred, such as when encoding JSON objects (a nil slice encodes to null, while []string{} encodes to the JSON array []).

When designing interfaces, avoid making a distinction between a nil slice and a non-nil, zero-length slice, as this can lead to subtle programming errors.
Pass a slice to a variadic function
ou can pass a slice s directly to a variadic funtion using the s... notation
func main() {
    primes := []int{2, 3, 5, 7}
    fmt.Println(Sum(primes...)) // 17
}   

func Sum(nums ...int) int {
    res := 0
    for _, n := range nums {
        res += n
    }
    return res
}

+++++++++++++++++++++++++++++++
var m map[string]int                // m == nil, len(m) == 0
m1 := make(map[string]float64)      // empty map of string-float64 pairs
m2 := make(map[string]float64, 100) // preallocate room for 100 entries
m3 := map[string]float64{
    "e":  2.71828,
    "pi": 3.1416,
}
fmt.Println(len(m1), len(m2), len(m3)) // 0 0 2
The default zero value of a map is nil. A nil map is equivalent to an empty map except that no elements can be added.
You create a map either by a map literal or a call to the make function, which takes an optional capacity as argument.
The built-in len function retrieves the number of key-value pairs.

Add, find and delete

m := make(map[string]float64)

m["pi"] = 3.1416 // Add a new key-value pair.
fmt.Println(m)   // map[pi:3.1416]

v1 := m["pi"]  // v1 == 3.1416
v2 := m["foo"] // v2 == 0 (zero value)

_, exists := m["pi"] // exists == true
_, exists = m["foo"] // exists == false

if x, ok := m["pi"]; ok { // Prints 3.1416.
    fmt.Println(x)
}

delete(m, "pi") // Delete a key-value pair.
fmt.Println(m)  // map[]
Iteration
m := map[string]float64{
    "e":  2.71828,
    "pi": 3.1416,
}
for key, value := range m { // order not specified 
    fmt.Println(key, value)
}
Check if a map contains a key
m := map[string]float64{"pi": 3.1416}

v1 := m["pi"]  // v1 == 3.1416
v2 := m["foo"] // v2 == 0.0 (zero value)

_, exists := m["pi"] // exists == true

if x, ok := m["pi"]; ok {
    fmt.Println(x) // 3.1416
}
Check if a map is empty
if len(m) == 0 {
    // m is empty
}
Count elements in a map
m := map[string]int{
    "key1": 1,
    "key2": 10,
    "key3": 100,
}
fmt.Println(len(m))  // 3
Get slices of keys and values from a map
keys := make([]keyType, 0, len(myMap))
values := make([]valueType, 0, len(myMap))

for k, v := range myMap {
	keys = append(keys, k)
	values = append(values, v)
}

Sort a map by key or value
 map is an unordered collection of key-value pairs.
If you need a stable iteration order, you must maintain a separate data structure.
This example uses a sorted slice of keys to print a map[string]int in key order.
m := map[string]int{"Alice": 23, "Eve": 2, "Bob": 25}

keys := make([]string, 0, len(m))
for k := range m {
	keys = append(keys, k)
}
sort.Strings(keys)

for _, k := range keys {
	fmt.Println(k, m[k])
}

Format a string without printing it

s := fmt.Sprintf("Size: %d MB.", 85) // s == "Size: 85 MB."

Type rune: a Unicode code point
The rune type is an alias for int32, and is used to emphasize than an integer represents a code point.
CII defines 128 characters, identified by the code points 0–127. It covers English letters, Latin numbers, and a few other characters.
Unicode, which is a superset of ASCII, defines a codespace of 1,114,112 code points. Unicode version 10.0 covers 139 modern and historic scripts (including runes, but not Klingon) as well as multiple symbol sets.
Strings and UTF-8
Note that a string is a sequence of bytes, not runes.
However, strings often contain Unicode text encoded in UTF-8, which encodes all Unicode code points using one to four bytes. Since Go source code itself is encoded as UTF-8, string literals will automatically get this encoding.
For simple cases where performance is a non-issue, fmt.Sprintf is your friend.
s := fmt.Sprintf("Size: %d MB.", 85) // s == "Size: 85 MB."
Fast concatenation with a string builder
The strings.Builder type is used to efficiently concatenate strings using write methods.

It offers a subset of the bytes.Buffer methods that allows it to safely avoid redundant copying.
The Grow method can be used to preallocate memory when the maximum size of the string is known.
var b strings.Builder
b.Grow(32)
for i, p := range []int{2, 3, 5, 7, 11, 13} {
    fmt.Fprintf(&b, "%d:%d, ", i+1, p)
}
s := b.String()   // no copying
s = s[:b.Len()-2] // no copying (removes trailing ", ")
fmt.Println(s)
1:2, 2:3, 3:5, 4:7, 5:11, 6:13
var buf bytes.Buffer
for i, p := range []int{2, 3, 5, 7, 11, 13} {
    fmt.Fprintf(&buf, "%d:%d, ", i+1, p)
}
buf.Truncate(buf.Len() - 2) // Remove trailing ", "
s := buf.String()           // Copy into a new string
fmt.Println(s)
buf := []byte("Size: ")
buf = strconv.AppendInt(buf, 85, 10)
buf = append(buf, " MB."...)
s := string(buf)
buf := make([]byte, 0, 16)
buf = append(buf, "Size: "...)
buf = strconv.AppendInt(buf, 85, 10)
buf = append(buf, " MB."...)
s := string(buf)
How to split a string into a slice
s := strings.Split("a,b,c", ",")
fmt.Println(s)
// Output: [a b c]
Use the strings.Fields function to split a string into substrings removing white space.
s := strings.Fields(" a \t b \n")
fmt.Println(s)
// Output: [a b]
if "Foo" == "Bar" {
    fmt.Println("Foo and Bar are equal.")
} else {
    fmt.Println("Foo and Bar are not equal.")
}
// Output: Foo and Bar are not equal.
Use <, >, <= or >= to determine lexical order.

f "Foo" < "Bar" {
    fmt.Println("Foo comes before Bar.")
} else {
    fmt.Println("Foo does not come before Bar.")
}
// Output: Foo does not come before Bar.
Convert string to/from byte slice
When you convert a string to a byte slice, you get a slice that contains the bytes of the string.
fmt.Println([]byte("abc日")
// [97 98 99 230 151 165]
Converting a slice of bytes to a string yields a string whose bytes are the elements of the slice.
b := []byte{'a', 'b', 'c', '\xe6', '\x97', '\xa5'}
s := string(b)
fmt.Println(s)
// Output: abc日
Convert string to/from rune slice
Converting a string to a slice of runes yields a slice whose elements are the Unicode code points of the string.
s := "abc日"
r := []rune(s)
fmt.Printf("%v\n", r) // [97 98 99 26085]
fmt.Printf("%U\n", r) // [U+0061 U+0062 U+0063 U+65E5]
Rune slice to string
Converting a slice of runes to a string yields a string that is the concatenation of the runes converted to UTF-8 encoded strings.

Values outside the range of valid Unicode code points are converted to \uFFFD, the Unicode replacement character �.
r := []rune{'\u0061', '\u0062', '\u0063', '\u65E5', -1}
s := string(r)
fmt.Println(s) // abc日�
Convert int/int64 to string
int to string
Use the strconv.Itoa function to convert an int to a decimal string.
str := strconv.Itoa(123) // str == "123"
nt64 to string
Use strconv.FormatInt to format an integer in a given base.
var n int64 = 32
str := strconv.FormatInt(n, 10) // decimal
fmt.Println(str)                // 32
var n int64 = 32
str := strconv.FormatInt(n, 16) // hexadecimal
fmt.Println(str)                // 20
Use strconv.Atoi to convert/parse a string to an int.
str := "123"
if n, err := strconv.Atoi(str); err == nil {
    fmt.Println(n+1)
} else {
    fmt.Println(str, "is not an integer.")
}
// Output: 124
String to int64
Use strconv.ParseInt to parse a decimal string (base 10) and check if it fits into a 64-bit signed integer.
str := "123"
n, err := strconv.ParseInt(str, 10, 64)
if err == nil {
    fmt.Printf("%d of type %T", n, n)
}
// Output: 123 of type int64
he two numeric arguments represent a base (0, 2 to 36) and a bit size (0 to 64).

If the first argument is 0, the base is implied by the string’s prefix: base 16 for "0x", base 8 for "0", and base 10 otherwise.

The second argument specifies the integer type that the result must fit into. Bit sizes 0, 8, 16, 32, and 64 correspond to int, int8, int16, int32, and int64.
Use the fmt.Sprintf method to convert a floating-point number to a string.
s := fmt.Sprintf("%f", 123.456) // s == "123.456000"
Use the strconv.ParseFloat function to convert a string to a floating-point number with the precision specified by bitSize: 32 for float32, or 64 for float64.

func ParseFloat(s string, bitSize int) (float64, error)
When bitSize is 32, the result still has type float64, but it will be convertible to float32 without changing its value.

f := "3.14159265"
if s, err := strconv.ParseFloat(f, 32); err == nil {
    fmt.Println(s) // 3.1415927410125732
}
if s, err := strconv.ParseFloat(f, 64); err == nil {
    fmt.Println(s) // 3.14159265
}
Raw string literals
Raw string literals, delimited by back quotes, can contain line breaks.
str := `First line
Second line`
fmt.Println(str)
Raw strings literals are interpreted literally and backslashes have no special meaning.

Interpreted string literals
To insert escape characters, use interpreted string literals delimited by double quotes.
str := "\tFirst line\n" +
"Second line"
fmt.Println(str)
Remove duplicate whitespace
space := regexp.MustCompile(`\s+`)
s := space.ReplaceAllString("Hello  \t \n world!", " ")
fmt.Printf("%q", s) // "Hello world!"
\s+ is a regular expression:

the character class \s matches a space, tab, new line, carriage return or form feed,
and + says “one or more of those”.
In other words, the code will replace each whitespace substring with a single space character.
Use the strings.TrimSpace function to remove leading and trailing whitespace as defined by Unicode.
s := strings.TrimSpace("\t Goodbye hair!\n ")
fmt.Printf("%q", s) // "Goodbye hair!"
s := strings.Repeat("da", 2) // "dada"
Reverse a UTF-8 encoded string
This function returns a string with the UTF-8 encoded characters of s in reverse order. Invalid UTF-8 sequences, if any, will be reversed byte by byte.
func ReverseUTF8(s string) string {
    res := make([]byte, len(s))
    prevPos, resPos := 0, len(s)
    for pos := range s {
        resPos -= pos - prevPos
        copy(res[resPos:], s[prevPos:pos])
        prevPos = pos
    }
    copy(res[0:], s[prevPos:])
    return string(res)
}
for _, s := range []string{
	"Ångström",
	"Hello, 世界",
	"\xff\xfe\xfd", // invalid UTF-8
} {
	fmt.Printf("%q\n", ReverseUTF8(s))
}
"mörtsgnÅ"
"界世 ,olleH"
"\xfd\xfe\xff"
_______________________________________
The Format method formats a time.Time.
The time.Parse function parses a date string.
func (t Time) Format(layout string) string
func Parse(layout, value string) (Time, error)
input := "2017-08-31"
layout := "2006-01-02"
t, _ := time.Parse(layout, input)
fmt.Println(t)                       // 2017-08-31 00:00:00 +0000 UTC
fmt.Println(t.Format("02-Jan-2006")) // 31-Aug-2017
Each Time has an associated Location, which is used for display purposes.

The method In returns a time with a specific location. Changing the location in this way changes only the presentation; it does not change the instant in time.

Here is a convenience function that changes the location associated with a time.
// TimeIn returns the time in UTC if the name is "" or "UTC".
// It returns the local time if the name is "Local".
// Otherwise, the name is taken to be a location name in
// the IANA Time Zone database, such as "Africa/Lagos".
func TimeIn(t time.Time, name string) (time.Time, error) {
    loc, err := time.LoadLocation(name)
    if err == nil {
        t = t.In(loc)
    }
    return t, err
}
for _, name := range []string{
	"",
	"Local",
	"Asia/Shanghai",
	"America/Metropolis",
} {
	t, err := TimeIn(time.Now(), name)
	if err == nil {
		fmt.Println(t.Location(), t.Format("15:04"))
	} else {
		fmt.Println(name, "<time unknown>")
	}
}
UTC 19:32
Local 20:32
Asia/Shanghai 03:32
America/Metropolis <time unknown>
Use time.Now and one of time.Unix or time.UnixNano to get a timestamp.
now := time.Now()      // current local time
sec := now.Unix()      // number of seconds since January 1, 1970 UTC
nsec := now.UnixNano() // number of nanoseconds since January 1, 1970 UTC

fmt.Println(now)  // time.Time
fmt.Println(sec)  // int64
fmt.Println(nsec) // int64
2009-11-10 23:00:00 +0000 UTC m=+0.000000000
1257894000
1257894000000000000
Get year, month, day from time
The Date function returns the year, month and day of a time.Time.
year, month, day := time.Now().Date()
fmt.Println(year, month, day)      // For example 2009 November 10
fmt.Println(year, int(month), day) // For example 2009 11 10
type Month int

const (
	January Month = 1 + iota
	February
	March
	April
	May
	June
	July
	August
	September
	October
	November
	December
)

How to find the day of week

The Weekday function returns returns the day of the week of a time.Time.
weekday := time.Now().Weekday()
fmt.Println(weekday)      // "Tuesday"
fmt.Println(int(weekday)) // "2"
Type Weekday
The time.Weekday type specifies a day of the week (Sunday = 0, …).
type Weekday int

const (
	Sunday Weekday = iota
	Monday
	Tuesday
	Wednesday
	Thursday
	Friday
	Saturday
)
Days between two dates
func main() {
    // The leap year 2000 had 366 days.
    t1 := Date(2000, 1, 1)
    t2 := Date(2001, 1, 1)
    days := t2.Sub(t1).Hours() / 24
    fmt.Println(days) // 366
}
func Date(year, month, day int) time.Time {
    return time.Date(year, time.Month(month), day, 0, 0, 0, 0, time.UTC)
}
Days in a month
To compute the last day of a month, you can use the fact that time.Date accepts values outside their usual ranges – the values are normalized during the conversion.

To compute the number of days in February, look at the day before March 1.
func main() {
    t := Date(2000, 3, 0) // the day before 2000-03-01
    fmt.Println(t)        // 2000-02-29 00:00:00 +0000 UTC
    fmt.Println(t.Day())  // 29
}

func Date(year, month, day int) time.Time {
    return time.Date(year, time.Month(month), day, 0, 0, 0, 0, time.UTC)
}
AddDate normalizes its result in the same way. For example, adding one month to October 31 yields December 1, the normalized form of November 31.

t = Date(2000, 10, 31).AddDate(0, 1, 0) // a month after October 31
fmt.Println(t)                          // 2000-12-01 00:00:00 +0000 UTC
Measure execution time

start := time.Now()
// Code to measure
duration := time.Since(start)

// Formatted string, such as "2h3m0.5s" or "4.503μs"
fmt.Println(duration)

// Nanoseconds as int64
fmt.Println(duration.Nanoseconds())
Measure a function call
You can track the execution time of a complete function call with this one-liner, which logs the result to the standard error stream.
func foo() {
    defer duration(track("foo"))
    // Code to measure
}
func track(msg string) (string, time.Time) {
    return msg, time.Now()
}

func duration(msg string, start time.Time) {
    log.Printf("%v: %v\n", msg, time.Since(start))
}

A struct is a typed collection of fields, useful for grouping data into records.
type Student struct {
    Name string
    Age  int
}

var a Student    // a == Student{"", 0}
a.Name = "Alice" // a == Student{"Alice", 0}

var pa *Student   // pa == nil
pa = new(Student) // pa == &Student{"", 0}
pa.Name = "Alice" // pa == &Student{"Alice", 0}
    
b := Student{ // b == Student{"Bob", 0}
    Name: "Bob",
}
    
pb := &Student{ // pb == &Student{"Bob", 8}
    Name: "Bob",
    Age:  8,
}

c := Student{"Cecilia", 5} // c == Student{"Cecilia", 5}

Basics
Structs and arrays are copied when used in assignments and passed as arguments to functions. With pointers this can be avoided.

Pointers store addresses of objects. The addresses can be passed around more efficiently than the actual objects.

A pointer has type *T. The keyword new allocates a new object and returns its address.
type Student struct {
    Name string
}

var ps *Student = new(Student) // ps holds the address of the new struct
ps := new(Student)
s := Student{"Alice"} // s holds the actual struct 
ps := &s              // ps holds the address of the struct 
The & operator can also be used with composite literals. The two lines above can be written as

ps := &Student{"Alice"}
Pointer indirection
For a pointer x, the pointer indirection *x denotes the value which x points to. Pointer indirection is rarely used, since Go can automatically take the address of a variable.
ps := new(Student)
ps.Name = "Alice" // same as (*ps).Name = "Alice"
Pointers as parameters
When using a pointer to modify an object, you’re affecting all code that uses the object.
/ Bob is a function that has no effect.
func Bob(s Student) {
    s.Name = "Bob" // changes only the local copy
}

// Charlie sets pp.Name to "Charlie".
func Charlie(ps *Student) {
    ps.Name = "Charlie"
}

func main() {
    s := Student{"Alice"}

    Bob(s)
    fmt.Println(s) // prints {Alice}

    Charlie(&s)
    fmt.Println(s) // prints {Charlie}
}
Untyped numeric constants with no limits
const a uint = 17
const b = 55
An untyped constant has no limits. When it’s used in a context that requires a type, a type will be inferred and a limit applied.
const big = 10000000000  // Ok, even thought it's too big for an int.
const bigger = big * 100 // Still ok.
var i int = big / 100    // No problem: the new result fits in an int.

// Compile time error: "constant 10000000000 overflows int"
var j int = big
The inferred type is determined by the syntax of the value:

123 gets type int, and
123.4 becomes a float64.
The other possibilities are rune (alias for int32) and complex128.

Enumerations
Go does not have enumerated types. Instead, you can use the special name iota in a single const declaration to get a series of increasing values. When an initialization expression is omitted for a const, it reuses the preceding expressio
const (
    red = iota // red == 0
    blue       // blue == 1
    green      // green == 2
)
Enum with String function
yourbasic.org/golang
Basic solution
A group of constants enumerated with iota might do the job.
const (
    Sunday    int = iota // Sunday == 0
    Monday               // Monday == 1
    Tuesday              // Tuesday == 2
    Wednesday            // …
    Thursday
    Friday
    Saturday
)
The iota keyword represents successive integer constants 0, 1, 2,…
It resets to 0 whenever the word const appears in the source code,
and increments after each const specification.
In the example, we also rely on the fact that expressions are implicitly repeated in a paren­thesized const declaration – this indicates a repetition of the preceding expression and its type.

type Suite int

const (
    Spades Suite = iota
    Hearts
    Diamonds
    Clubs
)
and give it a String function:

func (s Suite) String() string {
	return [...]string{"Spades", "Hearts", "Diamonds", "Clubs"}[s]
}
Here is the new type in action.

var s Suite = Hearts
fmt.Print(s)
switch s {
case Spades:
	fmt.Println(" are best.")
case Hearts:
	fmt.Println(" are second best.")
default:
	fmt.Println(" aren't very good.")
}
Hearts are second best.
Make slices, maps and channels
yourbasic.org/golang
Slices, maps and channels can be created with the built-in make function. The memory is initialized with zero values.

Call	Type	Description
make(T, n)	slice	slice of type T with length n
make(T, n, c)		capacity c
make(T)	map	map of type T
make(T, n)		initial room for approximately n elements
make(T)	channel	unbuffered channel of type T
make(T, n)		buffered channel with buffer size n
s := make([]int, 10, 100)      // slice with len(s) == 10, cap(s) == 100
m := make(map[string]int, 100) // map with initial room for ~100 elements
c := make(chan int, 10)        // channel with a buffer size of 10
Slices, arrays and maps can also be created with composite literals.

s := []string{"f", "o", "o"} // slice with len(s) == 3, cap(s) == 3
a := [...]int{1, 2}          // array with len(a) == 2
m := map[string]float64{     // map with two key-value elements
    "e":  2.71828,
    "pi": 3.1416,
}
Methods for all types
yourbasic.org/golang
Any type declared in a type definition can have methods attached.

A method is a function with a receiver argument.
The receiver appears between the func keyword and the method name.
You can define methods on any type declared in a type definition.
In this example, the Value method is associated with MyType. The method receiver is called p.

type MyType struct {
    n int
}

func (p *MyType) Value() int { return p.n }

func main() {
    pm := new(MyType)
    fmt.Println(pm.Value()) // 0 (zero value)
}
If you convert the value to a different type, the new value will have the methods of the new type, not those of the old type.

type MyInt int

func (m MyInt) Positive() bool { return m > 0 }

func main() {
    var m MyInt = 2
    m = m * m // The operators of the underlying type still apply.

    fmt.Println(m.Positive())         // true
    fmt.Println(MyInt(-1).Positive()) // false

    var n int
    n = int(m) // The conversion is required.
    n = m      // ILLEGAL
}
../main.go:14:4: cannot use m (type MyInt) as type int in assignment
Basics
An interface type consists of a set of method signatures. A variable of interface type can hold any value that implements these methods.

In this example both Temp and *Point implement the MyStringer interface.

type MyStringer interface {
	String() string
}
type Temp int

func (t Temp) String() string {
	return strconv.Itoa(int(t)) + " °C"
}

type Point struct {
	x, y int
}

func (p *Point) String() string {
	return fmt.Sprintf("(%d,%d)", p.x, p.y)
}
Actually, *Temp also implements MyStringer, since the method set of a pointer type *T is the set of all methods with receiver *T or T.

When you call a method on an interface value, the method of its underlying type is executed.

var x MyStringer

x = Temp(24)
fmt.Println(x.String()) // 24 °C

x = &Point{1, 2}
fmt.Println(x.String()) // (1,2)
Structural typing
A type implements an interface by implementing its methods. No explicit declaration is required.

In fact, the Temp, *Temp and *Point types also implement the standard library fmt.Stringer interface. The String method in this interface is used to print values passed as an operand to functions such as fmt.Println.

var x MyStringer

x = Temp(24)
fmt.Println(x) // 24 °C

x = &Point{1, 2}
fmt.Println(x) // (1,2)
The empty interface
The interface type that specifies no methods is known as the empty interface.

interface{}
An empty interface can hold values of any type since every type implements at least zero methods.

var x interface{}

x = 2.4
fmt.Println(x) // 2.4

x = &Point{1, 2}
fmt.Println(x) // (1,2)
The fmt.Println function is a chief example. It takes any number of arguments of any type.

func Println(a ...interface{}) (n int, err error)
Interface values
An interface value consists of a concrete value and a dynamic type: [Value, Type]

In a call to fmt.Printf, you can use %v to print the concrete value and %T to print the dynamic type.

var x MyStringer
fmt.Printf("%v %T\n", x, x) // <nil> <nil>

x = Temp(24)
fmt.Printf("%v %T\n", x, x) // 24 °C main.Temp

x = &Point{1, 2}
fmt.Printf("%v %T\n", x, x) // (1,2) *main.Point

x = (*Point)(nil)
fmt.Printf("%v %T\n", x, x) // <nil> *main.Point
The zero value of an interface type is nil, which is represented as [nil, nil].

Calling a method on a nil interface is a run-time error. However, it’s quite common to write methods that can handle a receiver value [nil, Type], where Type isn’t nil.

You can also use type assertions, type switches and reflection to access the dynamic type of an interface value. Find the type of an object has more details.

Equality
Two interface values are equal

if they have equal concrete values and identical dynamic types,
or if both are nil.
A value t of interface type T and a value x of non-interface type X are equal if

t’s concrete value is equal to x
and t’s dynamic type is identical to X.
var x MyStringer
fmt.Println(x == nil) // true

x = (*Point)(nil)
fmt.Println(x == nil) // false
In the second print statement, the concrete value of x equals nil, but its dynamic type is *Point, which is not nil.


